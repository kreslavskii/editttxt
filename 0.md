Продолжайте, но обратите внимание на багрепорт в https://github.com/kreslavskii/whisper/pull/1 в котором есть вот такие указания:



[modern\_pipeline/core/diarization\_engine.py](/kreslavskii/whisper/pull/1/files/706e3ced3abcc1f94084d49ea6040c8eaca4a564#diff-baca3a85a992357c921b4d10611bbb9374be76458f1a85747562c35b32371fcc)

cluster\_labels

)

  

seg.speaker \= f"SPEAKER\_{cluster\_id:02d}"

### Bug: Misaligned Data Causes Incorrect Assignments

In `_global_clustering`, the code collects embeddings only from segments where `embedding is not None`, but then iterates over all segments using the same index `i` to access `cluster_labels[i]`. This creates an index mismatch when some segments have `None` embeddings, causing the wrong cluster labels to be assigned to segments. The embeddings array will be shorter than the segments list, leading to incorrect speaker assignments.



  

self.utterances.append(utterance)

self.text \= " ".join(u.text for u in self.utterances)

self.end \= utterance.end


### Bug: Paragraph Start Time Initialization Error

The `add_utterance` method in the `Paragraph` class doesn't update the `start` time when adding the first utterance to an empty paragraph. If a paragraph is initialized with placeholder values and utterances are added later, the `start` field will remain at its initial value instead of being set to the first utterance's start time, causing incorrect timing information.


\# Если ресемплили, пересчитываем для original sr

if sr != 16000:

start\_sec \= start\_sec \* sr / 16000

end\_sec \= end\_sec \* sr / 16000


### Bug: Resampling Flaw Skews Audio Timestamps

In `_detect_speech_segments`, when the audio is resampled from the original sample rate to 16kHz for VAD processing, the timestamps are converted back incorrectly. The conversion `start_sec * sr / 16000` multiplies by the original sample rate instead of keeping the time in seconds, which will produce incorrect timestamp values that are off by a factor of `sr/16000`.



"""Проверка соотношения min/max speakers."""

\# Здесь values содержит уже валидированные поля

\# Полная валидация будет в model\_validator

return v


### Bug: Speaker Count Validation Ineffective

The `validate_speaker_counts` field validator for `min_speakers` in `DiarizationConfig` doesn't actually validate that `min_speakers <= max_speakers`. The validator receives `values` but never accesses `max_speakers` from it to perform the comparison, making the validation ineffective and allowing invalid configurations where `min_speakers > max_speakers`.



params\["min\_speakers"\] \= max(2, self.config.min\_speakers)

else:

params\["min\_speakers"\] \= self.config.min\_speakers

params\["max\_speakers"\] \= self.config.max\_speakers


### Bug: Speaker count parameter inconsistency

In `_run_pyannote`, when `num_speakers` is provided, the code sets `params["num_speakers"]` and `params["min_speakers"]` but doesn't set `params["max_speakers"]`. This is inconsistent with the else branch where both `min_speakers` and `max_speakers` are set. The pyannote pipeline may behave unexpectedly when `num_speakers` is specified without a corresponding `max_speakers` constraint, potentially allowing more speakers than intended.

